(define-library (loki hamt)
(import (scheme base))
(import (srfi 69))
(import (srfi 151))
(export make-hamt hamt? hamt/insert hamt/get hamt/delete hamt/lookup)
(begin

(define (vector-head vector end)
  (vector-copy vector 0 end))

(define (vector-tail vector start)
  (vector-copy vector start (vector-length vector)))

(define (filter! pred lis)
  (let recur ((lis lis))
    (if (pair? lis)	
        (cond ((pred (car lis))
               (set-cdr! lis (recur (cdr lis)))
               lis)
              (else (recur (cdr lis))))
        lis)))

(define (del-assq! obj alist)
  (let ((obj-car (car obj)))
    (filter!
      (lambda (a) (eq? (car a) obj-car))
      alist)))

(define (hamt-hash x) (hash x))

;; liberal guess at 25-bits, we have to truncate to keep everything
;; fixnum
(define m1 #x1555555)
(define m2 #x1333333)
(define m4 #x10F0F0F)
(define (popcount x)
  (let* ((x (- x (bitwise-and (arithmetic-shift x -1) m1)))
         (x (+ (bitwise-and x m2) (bitwise-and (arithmetic-shift x -2) m2)))
         (x (bitwise-and (+ x (arithmetic-shift x -4)) m4))
         (x (+ x (arithmetic-shift x -8))))
    (bitwise-and (+ x (arithmetic-shift x -16)) #x3f)))

(define-record-type <hamt-empty>
  (make-hamt) hamt-empty?)
(define-record-type <hamt-bitmap>
  (make-hamt-bitmap bitmap vector)
  hamt-bitmap?
  (bitmap hamt-bitmap-bitmap)
  (vector hamt-bitmap-vector))
(define-record-type <hamt-leaf>
  (make-hamt-leaf key real-key value)
  hamt-leaf?
  (key hamt-leaf-key)
  (real-key hamt-leaf-real-key)
  (value hamt-leaf-value))
(define-record-type <hamt-collision>
  (make-hamt-collision key alist)
  hamt-collision?
  (key hamt-collision-key)
  (alist hamt-collision-alist))

(define (hamt? t) (or (hamt-empty? t) (hamt-bitmap? t) (hamt-leaf? t) (hamt-collision? t)))

(define hamt/bits-per-subkey 4)
(define hamt/subkey-mask #xF)
(define (hamt/mask-index b m) (popcount (bitwise-and b (- m 1))))
(define (hamt/mask k s) (arithmetic-shift 1 (hamt/subkey k s)))
(define (hamt/subkey k s) (bitwise-and (arithmetic-shift k (- 0 s)) hamt/subkey-mask))

(define (%lookup k rk s t sc fc)
  (cond
        ((hamt-bitmap? t)
         (let ((m (hamt/mask k s))
               (b (hamt-bitmap-bitmap t)))
           (if (= (bitwise-and b m) 0)
             (fc)
             (%lookup k rk
                     (+ s hamt/bits-per-subkey)
                     (vector-ref (hamt-bitmap-vector t)
                                 (hamt/mask-index b m))
                     sc
                     fc))))
        ((hamt-leaf? t)
         (if (and (= (hamt-leaf-key t) k) (eq? (hamt-leaf-real-key t) rk))
           (sc (hamt-leaf-value t))
           (fc)))
        ((hamt-empty? t) (fc))
        ((hamt-collision? t)
         (let ((r (assq rk (hamt-collision-alist t))))
           (if (not r)
             (fc)
             (sc (cadr r)))))
        (else (error "invalid datatype passed to lookup"))))

(define (%insert kx rkx s x t)
  (cond
        ((hamt-bitmap? t)
         (let* ((b (hamt-bitmap-bitmap t))
                (v (hamt-bitmap-vector t))
                (m (hamt/mask kx s))
                (i (hamt/mask-index b m)))
           (if (= (bitwise-and b m) 0)
             (let* ((l (make-hamt-leaf kx rkx x))
                    (vp (vector-append (vector-head v i) (vector l) (vector-tail v i)))
                    (bp (bitwise-ior b m)))
               (make-hamt-bitmap bp vp)
               )
             (let* ((st (vector-ref v i))
                    (stp (%insert kx rkx (+ s hamt/bits-per-subkey) x st))
                    (vp (vector-copy v)))
               (vector-set! vp i stp)
               (make-hamt-bitmap b vp)
               )
             )
           ))
        ((hamt-leaf? t)
         (let ((ky  (hamt-leaf-key t))
               (rky (hamt-leaf-real-key t))
               (y   (hamt-leaf-value t)))
           (if (= ky kx)
             (if (eq? rky rkx)
               (make-hamt-leaf kx rkx x)
               (%insert kx rkx s x (make-hamt-collision kx (list (list rky y)))))
             (%insert kx rkx s x (make-hamt-bitmap (hamt/mask ky y) (vector t))))
           ))
        ((hamt-empty? t) (make-hamt-leaf kx rkx x))
        ((hamt-collision? t)
         (let ((alist (list-copy (hamt-collision-alist t))))
           (del-assq! rkx alist)
           (make-hamt-collision kx (cons (list rkx x) alist))))
        (else (error "invalid datatype passed to %insert"))
        )
  )

(define (%delete kx rkx s t)
  (cond ((hamt-empty? t) t)
        ((hamt-leaf? t)
         (let ((ky (hamt-leaf-key t))
               (rky (hamt-leaf-real-key t)))
           (if (and (= kx ky) (eq? rkx rky))
             (make-hamt)
             t)))
        ((hamt-bitmap? t)
         (let* ((b (hamt-bitmap-bitmap t))
                (v (hamt-bitmap-vector t))
                (m (hamt/mask kx s))
                (i (hamt/mask-index b m)))
           (if (= (bitwise-and b m) 0)
             t
             (let* ((st (vector-ref v i))
                    (stp (%delete kx rkx (+ s hamt/bits-per-subkey) st)))
               (if (hamt-empty? stp)
                 (if (= (popcount b) 1)
                   stp ;; (make-hamt)
                   (make-hamt-bitmap
                     (bitwise-and (bitwise-not m) b)
                     (vector-append (vector-head v i) (vector-tail v (+ i 1)))))
                 (if (eq? stp st)
                   t
                   (let ((vp (vector-copy v)))
                     (vector-set! vp i stp)
                     (make-hamt-bitmap b vp))))))))
        ((hamt-collision? t)
         (let ((alist (list-copy (hamt-collision-alist t))))
           (del-assq! rkx alist)
           (if (null? alist)
             (make-hamt)
             (if (null? (cdr alist))
               (make-hamt-leaf kx (car (car alist)) (cadr (car alist)))
               (make-hamt-collision kx alist)))))
        (else (error "invalid tree passed to %delete"))
    ))

(define (hamt/lookup hamt key if-found if-not-found)
  (%lookup (hamt-hash key) key 0 hamt if-found if-not-found))

(define (hamt/get hamt key default)
  (hamt/lookup hamt key (lambda (x) x) (lambda () default)))

(define (hamt/insert hamt key datum)
  (%insert (hamt-hash key) key 0 datum hamt))

(define (hamt/delete hamt key)
  (%delete (hamt-hash key) key 0 hamt))

))
